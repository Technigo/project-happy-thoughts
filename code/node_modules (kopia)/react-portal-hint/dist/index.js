import { Component, createRef, createElement, forwardRef, cloneElement, Fragment as Fragment$1 } from 'react';
import ResizeObserver from 'resize-observer-polyfill';
import { createPortal } from 'react-dom';
import { typeOf, Fragment, Portal, Suspense, isLazy, isForwardRef } from 'react-is';

let baseElement = document.querySelector("body");
function set(element) {
    if (typeof element === "string") {
        const el = document.querySelectorAll(element);
        baseElement = ("length" in el ? el[0] : el);
    }
    else if (element instanceof HTMLElement) {
        baseElement = element;
    }
    else {
        throw Error("Invalid base element");
    }
}
function get() {
    if (!baseElement) {
        throw new Error("The base element is not set.");
    }
    return baseElement;
}

const initialState = {
    contentRect: null,
    onceRendered: false,
    transformed: false
};
function placeToAttempts(place) {
    switch (place) {
        case "top":
        case "bottom":
        case "left":
        case "right":
            return [place];
        case "column":
            return ["top", "bottom"];
        case "row":
            return ["left", "right"];
        case "start":
            return ["top", "left"];
        case "end":
            return ["bottom", "right"];
    }
}
function calculatePosition(placeAttempts, targetRect, contentRect, safetyMargin) {
    let top = null;
    let left = null;
    let showingPlace = null;
    for (const place of placeAttempts) {
        showingPlace = place;
        if (place === "top") {
            const targetHorizontalCenter = (targetRect.left + targetRect.right) / 2;
            const targetTop = targetRect.top;
            const contentWidth = contentRect.width;
            const contentHeight = contentRect.height;
            left = targetHorizontalCenter - contentWidth / 2;
            top = targetTop - contentHeight;
            // check if valid position
            if (safetyMargin <= top &&
                safetyMargin <= left &&
                left + contentWidth + safetyMargin < window.innerWidth) {
                break;
            }
        }
        else if (place === "bottom") {
            const targetBottom = targetRect.bottom;
            const targetHorizontalCenter = (targetRect.left + targetRect.right) / 2;
            const contentWidth = contentRect.width;
            const contentHeight = contentRect.height;
            left = targetHorizontalCenter - contentWidth / 2;
            top = targetBottom;
            // check if valid position
            if (top + contentHeight + safetyMargin < window.innerHeight &&
                safetyMargin <= left &&
                left + contentWidth + safetyMargin < window.innerWidth) {
                break;
            }
        }
        else if (place === "left") {
            const targetLeft = targetRect.left;
            const targetVerticalCenter = (targetRect.top + targetRect.bottom) / 2;
            const contentWidth = contentRect.width;
            const contentHeight = contentRect.height;
            left = targetLeft - contentWidth;
            top = targetVerticalCenter - contentHeight / 2;
            // check if valid position
            if (safetyMargin <= left &&
                safetyMargin <= top &&
                top + contentHeight + safetyMargin < window.innerHeight) {
                break;
            }
        }
        else if (place === "right") {
            const targetRight = targetRect.right;
            const targetVerticalCenter = (targetRect.top + targetRect.bottom) / 2;
            const contentWidth = contentRect.width;
            const contentHeight = contentRect.height;
            left = targetRight;
            top = targetVerticalCenter - contentHeight / 2;
            // check if valid position
            if (left + contentWidth + safetyMargin < window.innerWidth &&
                safetyMargin <= top &&
                top + contentHeight + safetyMargin < window.innerHeight) {
                break;
            }
        }
        else {
            throw new Error("Invalid argument `place`.");
        }
    }
    return top !== null && left !== null && showingPlace !== null
        ? { top, left, place: showingPlace }
        : null;
}
class HintBody extends Component {
    constructor(props) {
        super(props);
        this.state = initialState;
        this.el = document.createElement("div");
        this.ref = createRef();
        this.modalRoot = null;
        this.ro = new ResizeObserver((entries) => {
            if (entries && entries[0] && this.ref.current) {
                // too problematic code. ResizeObserver's rect didn't work well
                this.setState({
                    contentRect: this.ref.current.getBoundingClientRect(),
                    onceRendered: true
                });
            }
        });
        this.onTransitionEnd = () => {
            if (this.props.usesTransition &&
                !this.props.shows &&
                this.props.onDisappeared) {
                this.props.onDisappeared();
            }
        };
        this.el.setAttribute("style", "display: inline-block; float: left");
        this.modalRoot = get();
    }
    componentDidMount() {
        if (this.modalRoot === null) {
            throw new Error("Modal root element is invalid.");
        }
        if (!this.ref.current) {
            throw new Error("Reference to the component is invalid.");
        }
        this.modalRoot.appendChild(this.el);
        this.ro.observe(this.ref.current);
        if (this.props.rendersSmoothly) {
            setTimeout(() => {
                this.setState({ transformed: true });
            }, 50);
        }
    }
    componentWillUnmount() {
        if (this.modalRoot) {
            this.modalRoot.removeChild(this.el);
        }
        this.ro.disconnect();
    }
    render() {
        let position = null;
        let showingPlace = "";
        if (this.state.contentRect) {
            const attempts = this.props.place instanceof Array
                ? this.props.place
                : placeToAttempts(this.props.place);
            const result = calculatePosition(attempts, this.props.rect, this.state.contentRect, this.props.safetyMargin);
            if (result !== null) {
                const { place, ...pos } = result;
                position = pos;
                showingPlace = place;
            }
        }
        return createPortal(createElement("div", { ref: this.ref, style: {
                display: "inline-flex",
                position: "absolute",
                left: `0`,
                top: `0`,
                transform: position
                    ? `translate(${position.left}px,${position.top}px)`
                    : undefined,
                transition: this.props.rendersSmoothly && this.state.transformed
                    ? "transform 0.05s ease-in-out"
                    : undefined
            } },
            createElement("div", { onTransitionEnd: this.onTransitionEnd, className: [
                    this.props.bodyClass,
                    this.props.shows &&
                        (!this.props.usesTransition || this.state.onceRendered)
                        ? this.props.shownClass
                        : this.props.hiddenClass,
                    showingPlace
                ].join(" ") }, this.props.children)), this.el);
    }
}

const HintTarget = forwardRef(function HintTargetCore({ children, ...events }, ref) {
    if (typeof children === "undefined" || children === null) {
        return null;
    }
    switch (typeOf(children)) {
        case Fragment:
            throw new Error("Target with React Fragment is not supported");
        case Portal:
            throw new Error("Target with React Portal is not supported");
        case Suspense:
            throw new Error("Target with React Suspense is not supported");
    }
    if (Array.isArray(children)) {
        throw new Error("Target with React NodeArray is not supported");
    }
    else if (typeof children === "object") {
        if ("type" in children) {
            if (isLazy(children.type)) {
                throw new Error("Target with React lazy is not supported");
            }
            if (typeof children.type === "function" ||
                isForwardRef(children)) {
                // React Function/Class Component
                throw Error("Target with React Function/Class Component is not supported");
            }
            if (!("children" in children)) {
                // React element(s)
                // register events and ref to the targets
                return cloneElement(children, {
                    ...events,
                    ref
                });
            }
        }
        throw Error("Unknown");
    }
    // raw text
    return (createElement("span", Object.assign({}, events, { style: { display: "inline-flex" }, ref: ref }), children));
});

const initialState$1 = {
    rect: null,
    rendersBody: false,
    showsBody: false,
    originalPlace: null
};
const defaultProps = {
    place: "top",
    centralizes: true,
    bodyClass: "react-portal-hint__body",
    usesTransition: true,
    targetMoves: false,
    rendersSmoothly: true,
    events: ["mouse-hover"],
    safetyMarginOfHint: 4,
    keepsOriginalPlace: false
};
class ReactPortalHint extends Component {
    constructor() {
        super(...arguments);
        this.state = initialState$1;
        this.targetRef = createRef();
        this.ro = new ResizeObserver((entries) => {
            if (!this.props.targetMoves &&
                this.state.rendersBody &&
                entries &&
                entries[0]) {
                // too problematic code. ResizeObserver's rect didn't work well
                this.updateRect();
            }
        });
        this.intervalHandler = null;
        this.show = () => {
            if (!this.targetRef.current) {
                throw new Error("Reference to the component is invalid.");
            }
            this.setState({
                rendersBody: true,
                showsBody: true,
                rect: this.targetRef.current.getBoundingClientRect() // if observer works in all situation, this is not necessary
            });
        };
        this.hide = () => {
            this.setState({ showsBody: false });
        };
        this.updateRect = () => {
            if (this.targetRef.current) {
                this.setState({ rect: this.targetRef.current.getBoundingClientRect() });
            }
        };
        this.onClick = () => {
            if (this.props.events.includes("click")) {
                if (this.state.showsBody) {
                    this.hide();
                }
                else {
                    this.show();
                }
            }
        };
        this.onDoubleClick = () => {
            if (this.props.events.includes("double-click")) {
                if (this.state.showsBody) {
                    this.hide();
                }
                else {
                    this.show();
                }
            }
        };
        this.onFocus = () => {
            if (this.props.events.includes("focus")) {
                this.show();
            }
        };
        this.onBlur = () => {
            if (this.props.events.includes("focus")) {
                this.hide();
            }
        };
        this.onMouseEnter = () => {
            if (this.props.events.includes("mouse-hover")) {
                this.show();
            }
        };
        this.onMouseLeave = () => {
            if (this.props.events.includes("mouse-hover")) {
                this.hide();
            }
        };
        this.onDisappeared = () => {
            this.setState({ rendersBody: false });
        };
    }
    static setBaseElement(element) {
        set(element);
    }
    componentDidMount() {
        if (typeof this.props.children === "undefined" ||
            this.props.children === null) {
            return;
        }
        if (!this.targetRef.current) {
            throw new Error("Reference to the component is invalid.");
        }
        this.ro.observe(this.targetRef.current);
        this.intervalHandler = setInterval(() => {
            if (this.props.targetMoves && this.state.rendersBody) {
                this.updateRect();
            }
        }, 50);
    }
    componentWillUnmount() {
        this.ro.disconnect();
        if (this.intervalHandler !== null) {
            clearInterval(this.intervalHandler);
        }
    }
    render() {
        return (createElement(Fragment$1, null,
            createElement(HintTarget, { ref: this.targetRef, onClick: this.onClick, onDoubleClick: this.onDoubleClick, onFocus: this.onFocus, onBlur: this.onBlur, onMouseEnter: this.onMouseEnter, onMouseLeave: this.onMouseLeave }, this.props.children),
            this.state.rendersBody && this.state.rect && (createElement(HintBody, { rect: this.state.rect, place: this.props.place, safetyMargin: this.props.safetyMarginOfHint, rendersSmoothly: this.props.rendersSmoothly, shows: this.state.showsBody, bodyClass: this.props.bodyClass, shownClass: "shown", hiddenClass: "hidden", usesTransition: this.props.usesTransition, onDisappeared: this.onDisappeared }, typeof this.props.content === "function"
                ? this.props.content(this.state.rect)
                : this.props.content))));
    }
}
ReactPortalHint.defaultProps = defaultProps;

export default ReactPortalHint;
