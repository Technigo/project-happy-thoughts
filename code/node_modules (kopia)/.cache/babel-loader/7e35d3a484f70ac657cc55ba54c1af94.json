{"ast":null,"code":"var _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n/**\r\n * Calls all subscribers once in a period.\r\n */\n\n\nvar Periodic = function () {\n  /**\r\n   * @param {number} period - The interval (in milliseconds).\r\n   */\n  function Periodic(period) {\n    var _this = this;\n\n    _classCallCheck(this, Periodic);\n\n    this.subscribers = [];\n\n    this.trigger = function (dry_run) {\n      // Call all subscribers.\n      for (var _iterator = _this.subscribers, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\n        var _ref;\n\n        if (_isArray) {\n          if (_i >= _iterator.length) break;\n          _ref = _iterator[_i++];\n        } else {\n          _i = _iterator.next();\n          if (_i.done) break;\n          _ref = _i.value;\n        }\n\n        var subscriber = _ref;\n        subscriber();\n      } // Schedule next iteration.\n\n\n      _this.schedule();\n    };\n\n    this.period = period;\n  } // subscribers = new Set()\n\n\n  _createClass(Periodic, [{\n    key: \"start\",\n    value: function start() {\n      // Do nothing if already started.\n      if (this.scheduled) {\n        return;\n      } // Start\n\n\n      this.schedule();\n    }\n  }, {\n    key: \"schedule\",\n    value: function schedule() {\n      this.scheduled = setTimeout(this.trigger, this.period);\n    }\n  }, {\n    key: \"stop\",\n    value: function stop() {\n      clearTimeout(this.scheduled);\n      this.scheduled = undefined;\n    }\n  }, {\n    key: \"add\",\n    value: function add(subscriber) {\n      var _this2 = this; // Add subscriber.\n      // this.subscribers.add(subscriber)\n\n\n      if (this.subscribers.indexOf(subscriber) < 0) {\n        this.subscribers.push(subscriber);\n      } // If it's the first subscriber,\n      // start this periodical.\n      // if (this.subscribers.size === 1) {\n\n\n      if (this.subscribers.length === 1) {\n        this.start();\n      } // Return unsubscribe function.\n\n\n      return function () {\n        return _this2.remove(subscriber);\n      };\n    }\n  }, {\n    key: \"remove\",\n    value: function remove(subscriber) {\n      // Remove subscriber.\n      // this.subscribers.delete(subscriber)\n      if (this.subscribers.indexOf(subscriber) >= 0) {\n        this.subscribers.splice(this.subscribers.indexOf(subscriber), 1);\n      } // If it was the last subscriber,\n      // stop periodical time refresh.\n      // if (this.subscribers.size === 0) {\n\n\n      if (this.subscribers.length === 0) {\n        this.stop();\n      }\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      this.stop(); // this.subscribers.clear()\n\n      this.subscribers = [];\n    }\n  }]);\n\n  return Periodic;\n}();\n\nexport default Periodic;","map":{"version":3,"sources":["../source/Periodic.js"],"names":["Periodic","subscribers","setTimeout","subscriber","clearTimeout"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;AAAA;;;;;IAGqBA,Q;AAKpB;;;AAGA,WAAA,QAAA,CAAA,MAAA,EACA;AAAA,QAAA,KAAA,GAAA,IAAA;;AAAA,IAAA,eAAA,CAAA,IAAA,EAAA,QAAA,CAAA;;AAAA,SANAC,WAMA,GANc,EAMd;;AAAA,SAAA,OAAA,GAoBU,UAAA,OAAA,EACV;AACC;AACA,WAAA,IAAA,SAAA,GAAyB,KAAA,CAAzB,WAAA,EAAA,QAAA,GAAA,KAAA,CAAA,OAAA,CAAA,SAAA,CAAA,EAAA,EAAA,GAAA,CAAA,EAAA,SAAA,GAAA,QAAA,GAAA,SAAA,GAAA,SAAA,CAAA,MAAA,CAAA,QAAA,CAAA,EAAA,IAA2C;AAAA,YAAA,IAAA;;AAAA,YAAA,QAAA,EAAA;AAAA,cAAA,EAAA,IAAA,SAAA,CAAA,MAAA,EAAA;AAAA,UAAA,IAAA,GAAA,SAAA,CAAA,EAAA,EAAA,CAAA;AAAA,SAAA,MAAA;AAAA,UAAA,EAAA,GAAA,SAAA,CAAA,IAAA,EAAA;AAAA,cAAA,EAAA,CAAA,IAAA,EAAA;AAAA,UAAA,IAAA,GAAA,EAAA,CAAA,KAAA;AAAA;;AAAA,YAAhCE,UAAgC,GAAA,IAAA;AAC1CA,QAAAA,UAAAA;AACA,OAJF,CAMC;;;AACA,MAAA,KAAA,CAAA,QAAA;AA5BD,KAAA;;AACC,SAAA,MAAA,GAAA,MAAA;AACA,G,CATD;;;;;4BAYA;AACC;AACA,UAAI,KAAJ,SAAA,EAAoB;AACnB;AACA,OAJF,CAMC;;;AACA,WAAA,QAAA;AACA;;;+BAGD;AACC,WAAA,SAAA,GAAiBD,UAAAA,CAAW,KAAXA,OAAAA,EAAyB,KAA1C,MAAiBA,CAAjB;AACA;;;2BAcD;AACCE,MAAAA,YAAAA,CAAa,KAAbA,SAAAA,CAAAA;AACA,WAAA,SAAA,GAAA,SAAA;AACA;;;wBAEGD,U,EACJ;AAAA,UAAA,MAAA,GAAA,IAAA,CAAA,CACC;AACA;;;AACA,UAAI,KAAA,WAAA,CAAA,OAAA,CAAA,UAAA,IAAJ,CAAA,EAA8C;AAC7C,aAAA,WAAA,CAAA,IAAA,CAAA,UAAA;AACA,OALF,CAOC;AACA;AACA;;;AACA,UAAI,KAAA,WAAA,CAAA,MAAA,KAAJ,CAAA,EAAmC;AAClC,aAAA,KAAA;AACA,OAZF,CAcC;;;AACA,aAAO,YAAA;AAAA,eAAM,MAAA,CAAA,MAAA,CAAN,UAAM,CAAN;AAAP,OAAA;AACA;;;2BAEMA,U,EACP;AACC;AACA;AACA,UAAI,KAAA,WAAA,CAAA,OAAA,CAAA,UAAA,KAAJ,CAAA,EAA+C;AAC9C,aAAA,WAAA,CAAA,MAAA,CAAwB,KAAA,WAAA,CAAA,OAAA,CAAxB,UAAwB,CAAxB,EAAA,CAAA;AACA,OALF,CAOC;AACA;AACA;;;AACA,UAAI,KAAA,WAAA,CAAA,MAAA,KAAJ,CAAA,EAAmC;AAClC,aAAA,IAAA;AACA;AACD;;;8BAGD;AACC,WAAA,IAAA,GADD,CAEC;;AACA,WAAA,WAAA,GAAA,EAAA;AACA;;;;;;eAtFmBH,Q","sourcesContent":["/**\r\n * Calls all subscribers once in a period.\r\n */\r\nexport default class Periodic\r\n{\r\n\t// subscribers = new Set()\r\n\tsubscribers = []\r\n\r\n\t/**\r\n\t * @param {number} period - The interval (in milliseconds).\r\n\t */\r\n\tconstructor(period)\r\n\t{\r\n\t\tthis.period = period\r\n\t}\r\n\r\n\tstart()\r\n\t{\r\n\t\t// Do nothing if already started.\r\n\t\tif (this.scheduled) {\r\n\t\t\treturn\r\n\t\t}\r\n\r\n\t\t// Start\r\n\t\tthis.schedule()\r\n\t}\r\n\r\n\tschedule()\r\n\t{\r\n\t\tthis.scheduled = setTimeout(this.trigger, this.period)\r\n\t}\r\n\r\n\ttrigger = (dry_run) =>\r\n\t{\r\n\t\t// Call all subscribers.\r\n\t\tfor (const subscriber of this.subscribers) {\r\n\t\t\tsubscriber()\r\n\t\t}\r\n\r\n\t\t// Schedule next iteration.\r\n\t\tthis.schedule()\r\n\t}\r\n\r\n\tstop()\r\n\t{\r\n\t\tclearTimeout(this.scheduled)\r\n\t\tthis.scheduled = undefined\r\n\t}\r\n\r\n\tadd(subscriber)\r\n\t{\r\n\t\t// Add subscriber.\r\n\t\t// this.subscribers.add(subscriber)\r\n\t\tif (this.subscribers.indexOf(subscriber) < 0) {\r\n\t\t\tthis.subscribers.push(subscriber)\r\n\t\t}\r\n\r\n\t\t// If it's the first subscriber,\r\n\t\t// start this periodical.\r\n\t\t// if (this.subscribers.size === 1) {\r\n\t\tif (this.subscribers.length === 1) {\r\n\t\t\tthis.start()\r\n\t\t}\r\n\r\n\t\t// Return unsubscribe function.\r\n\t\treturn () => this.remove(subscriber)\r\n\t}\r\n\r\n\tremove(subscriber)\r\n\t{\r\n\t\t// Remove subscriber.\r\n\t\t// this.subscribers.delete(subscriber)\r\n\t\tif (this.subscribers.indexOf(subscriber) >= 0) {\r\n\t\t\tthis.subscribers.splice(this.subscribers.indexOf(subscriber), 1)\r\n\t\t}\r\n\r\n\t\t// If it was the last subscriber,\r\n\t\t// stop periodical time refresh.\r\n\t\t// if (this.subscribers.size === 0) {\r\n\t\tif (this.subscribers.length === 0) {\r\n\t\t\tthis.stop()\r\n\t\t}\r\n\t}\r\n\r\n\tdestroy()\r\n\t{\r\n\t\tthis.stop()\r\n\t\t// this.subscribers.clear()\r\n\t\tthis.subscribers = []\r\n\t}\r\n}"]},"metadata":{},"sourceType":"module"}