{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = positions;\n\nvar _getDirection = _interopRequireDefault(require(\"./getDirection\"));\n\nvar _functions = require(\"./functions\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    var ownKeys = Object.keys(source);\n\n    if (typeof Object.getOwnPropertySymbols === 'function') {\n      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n      }));\n    }\n\n    ownKeys.forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    });\n  }\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n/**\n * Sets tip max width safely for mobile\n */\n\n\nfunction getTipMaxWidth() {\n  return typeof document !== 'undefined' ? document.documentElement.clientWidth - _functions.bodyPadding * 2 : 1000;\n}\n/**\n * Parses align mode from direction if specified with hyphen, defaulting to middle if not -\n * e.g. 'left-start' is mode 'start' and 'left' would be the default of 'middle'\n */\n\n\nfunction parseAlignMode(direction) {\n  var directionArray = direction.split('-');\n\n  if (directionArray.length > 1) {\n    return directionArray[1];\n  }\n\n  return 'middle';\n}\n/**\n * Gets wrapper's left position for top/bottom tooltips as well as needed width restriction\n */\n\n\nfunction getUpDownPosition(tip, target, state, direction, alignMode, props) {\n  var left = -10000000;\n  var top;\n  var transform = state.showTip ? undefined : 'translateX(-10000000px)';\n  var arrowSpacing = (0, _functions.getArrowSpacing)(props);\n\n  if (tip) {\n    // get wrapper left position\n    var scrollLeft = (0, _functions.getScrollLeft)();\n    var targetRect = target.getBoundingClientRect();\n    var targetLeft = targetRect.left + scrollLeft;\n    var halfTargetWidth = Math.round(target.offsetWidth / 2);\n    var tipWidth = Math.min(getTipMaxWidth(), tip.offsetWidth);\n    var arrowCenter = targetLeft + halfTargetWidth;\n    var arrowLeft = arrowCenter - props.arrowSize;\n    var arrowRight = arrowCenter + props.arrowSize;\n\n    if (alignMode === 'start') {\n      left = props.arrow ? Math.min(arrowLeft, targetLeft) : targetLeft;\n    } else if (alignMode === 'end') {\n      var rightWithArrow = Math.max(arrowRight, targetLeft + target.offsetWidth);\n      var rightEdge = props.arrow ? rightWithArrow : targetLeft + target.offsetWidth;\n      left = Math.max(rightEdge - tipWidth, _functions.bodyPadding + scrollLeft);\n    } else {\n      var centeredLeft = targetLeft + halfTargetWidth - Math.round(tipWidth / 2);\n      var availableSpaceOnLeft = _functions.bodyPadding + scrollLeft;\n      left = Math.max(centeredLeft, availableSpaceOnLeft);\n    } // check for right overhang\n\n\n    var rightOfTip = left + tipWidth;\n    var rightOfScreen = scrollLeft + document.documentElement.clientWidth - _functions.bodyPadding;\n    var rightOverhang = rightOfTip - rightOfScreen;\n\n    if (rightOverhang > 0) {\n      left -= rightOverhang;\n    }\n\n    if (direction === 'up') {\n      top = targetRect.top + (0, _functions.getScrollTop)() - (tip.offsetHeight + arrowSpacing);\n    } else {\n      top = targetRect.bottom + (0, _functions.getScrollTop)() + arrowSpacing;\n    }\n  }\n\n  return {\n    left: left,\n    top: top,\n    transform: transform\n  };\n}\n/**\n * gets top position for left/right arrows\n */\n\n\nfunction getLeftRightPosition(tip, target, state, direction, alignMode, props) {\n  var left = -10000000;\n  var top = 0;\n  var transform = state.showTip ? undefined : 'translateX(-10000000px)';\n  var arrowSpacing = (0, _functions.getArrowSpacing)(props);\n  var arrowPadding = props.arrow ? _functions.minArrowPadding : 0;\n\n  if (tip) {\n    var scrollTop = (0, _functions.getScrollTop)();\n    var scrollLeft = (0, _functions.getScrollLeft)();\n    var targetRect = target.getBoundingClientRect();\n    var targetTop = targetRect.top + scrollTop;\n    var halfTargetHeight = Math.round(target.offsetHeight / 2);\n    var arrowTop = targetTop + halfTargetHeight - props.arrowSize;\n    var arrowBottom = targetRect.top + scrollTop + halfTargetHeight + props.arrowSize; // TODO: handle close to edges better\n\n    if (alignMode === 'start') {\n      top = props.arrow ? Math.min(targetTop, arrowTop) : targetTop;\n    } else if (alignMode === 'end') {\n      var topForBottomAlign = targetRect.bottom + scrollTop - tip.offsetHeight;\n      top = props.arrow ? Math.max(topForBottomAlign, arrowBottom - tip.offsetHeight) : topForBottomAlign;\n    } else {\n      // default to middle, but don't go below body\n      var centeredTop = Math.max(targetTop + halfTargetHeight - Math.round(tip.offsetHeight / 2), _functions.bodyPadding + scrollTop); // make sure it doesn't go below the arrow\n\n      top = Math.min(centeredTop, arrowTop - arrowPadding);\n    } // check for bottom overhang\n\n\n    var bottomOverhang = top - scrollTop + tip.offsetHeight + _functions.bodyPadding - window.innerHeight;\n\n    if (bottomOverhang > 0) {\n      // try to add the body padding below the tip, but don't offset too far from the arrow\n      top = Math.max(top - bottomOverhang, arrowBottom + arrowPadding - tip.offsetHeight);\n    }\n\n    if (direction === 'right') {\n      left = targetRect.right + arrowSpacing + scrollLeft;\n    } else {\n      left = targetRect.left - arrowSpacing - tip.offsetWidth + scrollLeft;\n    }\n  }\n\n  return {\n    left: left,\n    top: top,\n    transform: transform\n  };\n}\n/**\n * sets the Arrow styles based on direction\n */\n\n\nfunction getArrowStyles(target, tip, direction, state, props) {\n  if (!target || !props.arrow) {\n    return {\n      top: '0',\n      left: '-10000000px'\n    };\n  }\n\n  var targetRect = target.getBoundingClientRect();\n  var halfTargetHeight = Math.round(target.offsetHeight / 2);\n  var halfTargetWidth = Math.round(target.offsetWidth / 2);\n  var scrollTop = (0, _functions.getScrollTop)();\n  var scrollLeft = (0, _functions.getScrollLeft)();\n  var arrowSpacing = (0, _functions.getArrowSpacing)(props);\n  var borderStyles = {};\n\n  switch (direction) {\n    case 'right':\n      borderStyles.borderTop = \"\".concat(props.arrowSize, \"px solid transparent\");\n      borderStyles.borderBottom = \"\".concat(props.arrowSize, \"px solid transparent\");\n\n      if (props.background) {\n        borderStyles.borderRight = \"\".concat(props.arrowSize, \"px solid \").concat(props.background);\n      } else {\n        borderStyles.borderRightWidth = \"\".concat(props.arrowSize, \"px\");\n        borderStyles.borderRightStyle = 'solid';\n      }\n\n      return _objectSpread({}, borderStyles, {\n        top: state.showTip && tip ? targetRect.top + scrollTop + halfTargetHeight - props.arrowSize : '-10000000px',\n        left: targetRect.right + scrollLeft + arrowSpacing - props.arrowSize\n      });\n\n    case 'left':\n      borderStyles.borderTop = \"\".concat(props.arrowSize, \"px solid transparent\");\n      borderStyles.borderBottom = \"\".concat(props.arrowSize, \"px solid transparent\");\n\n      if (props.background) {\n        borderStyles.borderLeft = \"\".concat(props.arrowSize, \"px solid \").concat(props.background);\n      } else {\n        borderStyles.borderLeftWidth = \"\".concat(props.arrowSize, \"px\");\n        borderStyles.borderLeftStyle = 'solid';\n      }\n\n      return _objectSpread({}, borderStyles, {\n        top: state.showTip && tip ? targetRect.top + scrollTop + halfTargetHeight - props.arrowSize : '-10000000px',\n        left: targetRect.left + scrollLeft - arrowSpacing - 1\n      });\n\n    case 'up':\n      borderStyles.borderLeft = \"\".concat(props.arrowSize, \"px solid transparent\");\n      borderStyles.borderRight = \"\".concat(props.arrowSize, \"px solid transparent\"); // if color is styled with css, we need everything except border-color, if styled with props, we add entire border rule\n\n      if (props.background) {\n        borderStyles.borderTop = \"\".concat(props.arrowSize, \"px solid \").concat(props.background);\n      } else {\n        borderStyles.borderTopWidth = \"\".concat(props.arrowSize, \"px\");\n        borderStyles.borderTopStyle = 'solid';\n      }\n\n      return _objectSpread({}, borderStyles, {\n        left: state.showTip && tip ? targetRect.left + scrollLeft + halfTargetWidth - props.arrowSize : '-10000000px',\n        top: targetRect.top + scrollTop - arrowSpacing\n      });\n\n    case 'down':\n    default:\n      borderStyles.borderLeft = \"\".concat(props.arrowSize, \"px solid transparent\");\n      borderStyles.borderRight = \"\".concat(props.arrowSize, \"px solid transparent\");\n\n      if (props.background) {\n        borderStyles.borderBottom = \"10px solid \".concat(props.background);\n      } else {\n        borderStyles.borderBottomWidth = \"\".concat(props.arrowSize, \"px\");\n        borderStyles.borderBottomStyle = 'solid';\n      }\n\n      return _objectSpread({}, borderStyles, {\n        left: state.showTip && tip ? targetRect.left + scrollLeft + halfTargetWidth - props.arrowSize : '-10000000px',\n        top: targetRect.bottom + scrollTop + arrowSpacing - props.arrowSize\n      });\n  }\n}\n/**\n * Returns the positions style rules\n */\n\n\nfunction positions(direction, forceDirection, tip, target, state, props) {\n  var alignMode = parseAlignMode(direction);\n  var trimmedDirection = direction.split('-')[0];\n  var realDirection = trimmedDirection;\n\n  if (!forceDirection && tip) {\n    var testArrowStyles = props.arrow && getArrowStyles(target, tip, trimmedDirection, state, props);\n    realDirection = (0, _getDirection[\"default\"])(trimmedDirection, tip, target, props, _functions.bodyPadding, testArrowStyles);\n  }\n\n  var maxWidth = getTipMaxWidth(); // force the tip to display the width we measured everything at when visible\n\n  var width;\n\n  if (tip) {\n    // adding the exact width on the first render forces a bogus line break, so add 1px the first time\n    var spacer = tip.style.width ? 0 : 1;\n    width = Math.min(tip.offsetWidth, maxWidth) + spacer;\n  }\n\n  var tipPosition = realDirection === 'up' || realDirection === 'down' ? getUpDownPosition(tip, target, state, realDirection, alignMode, props) : getLeftRightPosition(tip, target, state, realDirection, alignMode, props);\n  return {\n    tip: _objectSpread({}, tipPosition, {\n      maxWidth: maxWidth,\n      width: width\n    }),\n    arrow: getArrowStyles(target, tip, realDirection, state, props),\n    realDirection: realDirection\n  };\n}","map":{"version":3,"sources":["/Users/beatricelundevall/Technigo/week11/project-happy-thoughts/code/node_modules/react-tooltip-lite/dist/position.js"],"names":["Object","defineProperty","exports","value","positions","_getDirection","_interopRequireDefault","require","_functions","obj","__esModule","_objectSpread","target","i","arguments","length","source","ownKeys","keys","getOwnPropertySymbols","concat","filter","sym","getOwnPropertyDescriptor","enumerable","forEach","key","_defineProperty","configurable","writable","getTipMaxWidth","document","documentElement","clientWidth","bodyPadding","parseAlignMode","direction","directionArray","split","getUpDownPosition","tip","state","alignMode","props","left","top","transform","showTip","undefined","arrowSpacing","getArrowSpacing","scrollLeft","getScrollLeft","targetRect","getBoundingClientRect","targetLeft","halfTargetWidth","Math","round","offsetWidth","tipWidth","min","arrowCenter","arrowLeft","arrowSize","arrowRight","arrow","rightWithArrow","max","rightEdge","centeredLeft","availableSpaceOnLeft","rightOfTip","rightOfScreen","rightOverhang","getScrollTop","offsetHeight","bottom","getLeftRightPosition","arrowPadding","minArrowPadding","scrollTop","targetTop","halfTargetHeight","arrowTop","arrowBottom","topForBottomAlign","centeredTop","bottomOverhang","window","innerHeight","right","getArrowStyles","borderStyles","borderTop","borderBottom","background","borderRight","borderRightWidth","borderRightStyle","borderLeft","borderLeftWidth","borderLeftStyle","borderTopWidth","borderTopStyle","borderBottomWidth","borderBottomStyle","forceDirection","trimmedDirection","realDirection","testArrowStyles","maxWidth","width","spacer","style","tipPosition"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = positions;\n\nvar _getDirection = _interopRequireDefault(require(\"./getDirection\"));\n\nvar _functions = require(\"./functions\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n/**\n * Sets tip max width safely for mobile\n */\nfunction getTipMaxWidth() {\n  return typeof document !== 'undefined' ? document.documentElement.clientWidth - _functions.bodyPadding * 2 : 1000;\n}\n/**\n * Parses align mode from direction if specified with hyphen, defaulting to middle if not -\n * e.g. 'left-start' is mode 'start' and 'left' would be the default of 'middle'\n */\n\n\nfunction parseAlignMode(direction) {\n  var directionArray = direction.split('-');\n\n  if (directionArray.length > 1) {\n    return directionArray[1];\n  }\n\n  return 'middle';\n}\n/**\n * Gets wrapper's left position for top/bottom tooltips as well as needed width restriction\n */\n\n\nfunction getUpDownPosition(tip, target, state, direction, alignMode, props) {\n  var left = -10000000;\n  var top;\n  var transform = state.showTip ? undefined : 'translateX(-10000000px)';\n  var arrowSpacing = (0, _functions.getArrowSpacing)(props);\n\n  if (tip) {\n    // get wrapper left position\n    var scrollLeft = (0, _functions.getScrollLeft)();\n    var targetRect = target.getBoundingClientRect();\n    var targetLeft = targetRect.left + scrollLeft;\n    var halfTargetWidth = Math.round(target.offsetWidth / 2);\n    var tipWidth = Math.min(getTipMaxWidth(), tip.offsetWidth);\n    var arrowCenter = targetLeft + halfTargetWidth;\n    var arrowLeft = arrowCenter - props.arrowSize;\n    var arrowRight = arrowCenter + props.arrowSize;\n\n    if (alignMode === 'start') {\n      left = props.arrow ? Math.min(arrowLeft, targetLeft) : targetLeft;\n    } else if (alignMode === 'end') {\n      var rightWithArrow = Math.max(arrowRight, targetLeft + target.offsetWidth);\n      var rightEdge = props.arrow ? rightWithArrow : targetLeft + target.offsetWidth;\n      left = Math.max(rightEdge - tipWidth, _functions.bodyPadding + scrollLeft);\n    } else {\n      var centeredLeft = targetLeft + halfTargetWidth - Math.round(tipWidth / 2);\n      var availableSpaceOnLeft = _functions.bodyPadding + scrollLeft;\n      left = Math.max(centeredLeft, availableSpaceOnLeft);\n    } // check for right overhang\n\n\n    var rightOfTip = left + tipWidth;\n    var rightOfScreen = scrollLeft + document.documentElement.clientWidth - _functions.bodyPadding;\n    var rightOverhang = rightOfTip - rightOfScreen;\n\n    if (rightOverhang > 0) {\n      left -= rightOverhang;\n    }\n\n    if (direction === 'up') {\n      top = targetRect.top + (0, _functions.getScrollTop)() - (tip.offsetHeight + arrowSpacing);\n    } else {\n      top = targetRect.bottom + (0, _functions.getScrollTop)() + arrowSpacing;\n    }\n  }\n\n  return {\n    left: left,\n    top: top,\n    transform: transform\n  };\n}\n/**\n * gets top position for left/right arrows\n */\n\n\nfunction getLeftRightPosition(tip, target, state, direction, alignMode, props) {\n  var left = -10000000;\n  var top = 0;\n  var transform = state.showTip ? undefined : 'translateX(-10000000px)';\n  var arrowSpacing = (0, _functions.getArrowSpacing)(props);\n  var arrowPadding = props.arrow ? _functions.minArrowPadding : 0;\n\n  if (tip) {\n    var scrollTop = (0, _functions.getScrollTop)();\n    var scrollLeft = (0, _functions.getScrollLeft)();\n    var targetRect = target.getBoundingClientRect();\n    var targetTop = targetRect.top + scrollTop;\n    var halfTargetHeight = Math.round(target.offsetHeight / 2);\n    var arrowTop = targetTop + halfTargetHeight - props.arrowSize;\n    var arrowBottom = targetRect.top + scrollTop + halfTargetHeight + props.arrowSize; // TODO: handle close to edges better\n\n    if (alignMode === 'start') {\n      top = props.arrow ? Math.min(targetTop, arrowTop) : targetTop;\n    } else if (alignMode === 'end') {\n      var topForBottomAlign = targetRect.bottom + scrollTop - tip.offsetHeight;\n      top = props.arrow ? Math.max(topForBottomAlign, arrowBottom - tip.offsetHeight) : topForBottomAlign;\n    } else {\n      // default to middle, but don't go below body\n      var centeredTop = Math.max(targetTop + halfTargetHeight - Math.round(tip.offsetHeight / 2), _functions.bodyPadding + scrollTop); // make sure it doesn't go below the arrow\n\n      top = Math.min(centeredTop, arrowTop - arrowPadding);\n    } // check for bottom overhang\n\n\n    var bottomOverhang = top - scrollTop + tip.offsetHeight + _functions.bodyPadding - window.innerHeight;\n\n    if (bottomOverhang > 0) {\n      // try to add the body padding below the tip, but don't offset too far from the arrow\n      top = Math.max(top - bottomOverhang, arrowBottom + arrowPadding - tip.offsetHeight);\n    }\n\n    if (direction === 'right') {\n      left = targetRect.right + arrowSpacing + scrollLeft;\n    } else {\n      left = targetRect.left - arrowSpacing - tip.offsetWidth + scrollLeft;\n    }\n  }\n\n  return {\n    left: left,\n    top: top,\n    transform: transform\n  };\n}\n/**\n * sets the Arrow styles based on direction\n */\n\n\nfunction getArrowStyles(target, tip, direction, state, props) {\n  if (!target || !props.arrow) {\n    return {\n      top: '0',\n      left: '-10000000px'\n    };\n  }\n\n  var targetRect = target.getBoundingClientRect();\n  var halfTargetHeight = Math.round(target.offsetHeight / 2);\n  var halfTargetWidth = Math.round(target.offsetWidth / 2);\n  var scrollTop = (0, _functions.getScrollTop)();\n  var scrollLeft = (0, _functions.getScrollLeft)();\n  var arrowSpacing = (0, _functions.getArrowSpacing)(props);\n  var borderStyles = {};\n\n  switch (direction) {\n    case 'right':\n      borderStyles.borderTop = \"\".concat(props.arrowSize, \"px solid transparent\");\n      borderStyles.borderBottom = \"\".concat(props.arrowSize, \"px solid transparent\");\n\n      if (props.background) {\n        borderStyles.borderRight = \"\".concat(props.arrowSize, \"px solid \").concat(props.background);\n      } else {\n        borderStyles.borderRightWidth = \"\".concat(props.arrowSize, \"px\");\n        borderStyles.borderRightStyle = 'solid';\n      }\n\n      return _objectSpread({}, borderStyles, {\n        top: state.showTip && tip ? targetRect.top + scrollTop + halfTargetHeight - props.arrowSize : '-10000000px',\n        left: targetRect.right + scrollLeft + arrowSpacing - props.arrowSize\n      });\n\n    case 'left':\n      borderStyles.borderTop = \"\".concat(props.arrowSize, \"px solid transparent\");\n      borderStyles.borderBottom = \"\".concat(props.arrowSize, \"px solid transparent\");\n\n      if (props.background) {\n        borderStyles.borderLeft = \"\".concat(props.arrowSize, \"px solid \").concat(props.background);\n      } else {\n        borderStyles.borderLeftWidth = \"\".concat(props.arrowSize, \"px\");\n        borderStyles.borderLeftStyle = 'solid';\n      }\n\n      return _objectSpread({}, borderStyles, {\n        top: state.showTip && tip ? targetRect.top + scrollTop + halfTargetHeight - props.arrowSize : '-10000000px',\n        left: targetRect.left + scrollLeft - arrowSpacing - 1\n      });\n\n    case 'up':\n      borderStyles.borderLeft = \"\".concat(props.arrowSize, \"px solid transparent\");\n      borderStyles.borderRight = \"\".concat(props.arrowSize, \"px solid transparent\"); // if color is styled with css, we need everything except border-color, if styled with props, we add entire border rule\n\n      if (props.background) {\n        borderStyles.borderTop = \"\".concat(props.arrowSize, \"px solid \").concat(props.background);\n      } else {\n        borderStyles.borderTopWidth = \"\".concat(props.arrowSize, \"px\");\n        borderStyles.borderTopStyle = 'solid';\n      }\n\n      return _objectSpread({}, borderStyles, {\n        left: state.showTip && tip ? targetRect.left + scrollLeft + halfTargetWidth - props.arrowSize : '-10000000px',\n        top: targetRect.top + scrollTop - arrowSpacing\n      });\n\n    case 'down':\n    default:\n      borderStyles.borderLeft = \"\".concat(props.arrowSize, \"px solid transparent\");\n      borderStyles.borderRight = \"\".concat(props.arrowSize, \"px solid transparent\");\n\n      if (props.background) {\n        borderStyles.borderBottom = \"10px solid \".concat(props.background);\n      } else {\n        borderStyles.borderBottomWidth = \"\".concat(props.arrowSize, \"px\");\n        borderStyles.borderBottomStyle = 'solid';\n      }\n\n      return _objectSpread({}, borderStyles, {\n        left: state.showTip && tip ? targetRect.left + scrollLeft + halfTargetWidth - props.arrowSize : '-10000000px',\n        top: targetRect.bottom + scrollTop + arrowSpacing - props.arrowSize\n      });\n  }\n}\n/**\n * Returns the positions style rules\n */\n\n\nfunction positions(direction, forceDirection, tip, target, state, props) {\n  var alignMode = parseAlignMode(direction);\n  var trimmedDirection = direction.split('-')[0];\n  var realDirection = trimmedDirection;\n\n  if (!forceDirection && tip) {\n    var testArrowStyles = props.arrow && getArrowStyles(target, tip, trimmedDirection, state, props);\n    realDirection = (0, _getDirection[\"default\"])(trimmedDirection, tip, target, props, _functions.bodyPadding, testArrowStyles);\n  }\n\n  var maxWidth = getTipMaxWidth(); // force the tip to display the width we measured everything at when visible\n\n  var width;\n\n  if (tip) {\n    // adding the exact width on the first render forces a bogus line break, so add 1px the first time\n    var spacer = tip.style.width ? 0 : 1;\n    width = Math.min(tip.offsetWidth, maxWidth) + spacer;\n  }\n\n  var tipPosition = realDirection === 'up' || realDirection === 'down' ? getUpDownPosition(tip, target, state, realDirection, alignMode, props) : getLeftRightPosition(tip, target, state, realDirection, alignMode, props);\n  return {\n    tip: _objectSpread({}, tipPosition, {\n      maxWidth: maxWidth,\n      width: width\n    }),\n    arrow: getArrowStyles(target, tip, realDirection, state, props),\n    realDirection: realDirection\n  };\n}"]},"metadata":{},"sourceType":"script"}